function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms));
}

function triggerInput(input, value) {
    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;
    const inputEvent = new Event('input', { bubbles: true });
    const keydownEvent = new KeyboardEvent('keydown', { key: value[value.length - 1] || ' ', bubbles: true });
    const keyupEvent = new KeyboardEvent('keyup', { key: value[value.length - 1] || ' ', bubbles: true });

    nativeInputValueSetter.call(input, value);
    input.dispatchEvent(inputEvent);
    input.dispatchEvent(keydownEvent);
    input.dispatchEvent(keyupEvent);
}

function triggerBackspace(input, value) {
    const nativeInputValueSetter = Object.getOwnPropertyDescriptor(window.HTMLInputElement.prototype, 'value').set;
    const backspaceEvent = new KeyboardEvent('keydown', { key: 'Backspace', bubbles: true });
    const inputEvent = new Event('input', { bubbles: true });
    const keyupEvent = new KeyboardEvent('keyup', { key: 'Backspace', bubbles: true });

    nativeInputValueSetter.call(input, value);
    input.dispatchEvent(backspaceEvent);
    input.dispatchEvent(inputEvent);
    input.dispatchEvent(keyupEvent);
}

function clickElement(element) {
    if (element && !element.disabled) {
        try {
            element.dispatchEvent(new MouseEvent('mouseover', { bubbles: true, cancelable: true, view: window }));
            element.dispatchEvent(new MouseEvent('mousedown', { bubbles: true, cancelable: true, view: window }));
            element.dispatchEvent(new MouseEvent('mouseup', { bubbles: true, cancelable: true, view: window }));
            element.dispatchEvent(new MouseEvent('click', { bubbles: true, cancelable: true, view: window }));
            console.log(`âœ… ç‚¹å‡»å…ƒç´ : ${element.textContent.trim()}`);
            return true;
        } catch (e) {
            console.log(`âŒ ç‚¹å‡»å¤±è´¥: ${e.message}`);
            return false;
        }
    }
    return false;
}

function triggerSingleTab() {
    const el = document.activeElement;
    if (el) {
        el.dispatchEvent(new KeyboardEvent('keydown', {key: 'Tab', code: 'Tab', keyCode: 9, which: 9, bubbles: true}));
        el.dispatchEvent(new KeyboardEvent('keyup', {key: 'Tab', code: 'Tab', keyCode: 9, which: 9, bubbles: true}));
    }
}

function findButton(text) {
    const buttons = document.querySelectorAll('button');
    return Array.from(buttons).find(btn => btn.textContent.includes(text));
}

async function waitForInputFocusAndNewWord(maxAttempts = 10) {
    let attempts = 0;
    while (attempts < maxAttempts) {
        const input = document.querySelector('input[type="text"]');
        const wordElems = document.querySelectorAll('div[class*="text-"]');
        const activeWord = Array.from(wordElems).find(el =>
            el.innerText.trim().length > 0 &&
            window.getComputedStyle(el).color === 'rgb(255, 255, 255)'
        );

        if (input && document.activeElement === input && activeWord) {
            return true;
        }
        triggerSingleTab();
        await sleep(250);
        attempts++;
    }
    return false;
}

async function triggerDoubleTab() {
    triggerSingleTab();
    await sleep(100);
    triggerSingleTab();
}

function randomWrongChar() {
    return String.fromCharCode(97 + Math.floor(Math.random() * 26));
}

// âœ… å‚æ•°é…ç½®
const ERROR_PROB = 0.05;  // 5% æ¯ä¸ªå­—ç¬¦å¯èƒ½å‡ºé”™
const FIX_PROB = 0.66;     // 60% çš„é”™è¯¯ä¼šä¿®æ­£
let submitCount = 0;

// âœ… æ·»åŠ æµ®åŠ¨è®¡æ•°å™¨
function showCounter() {
    let counter = document.getElementById('submit-counter');
    if (!counter) {
        counter = document.createElement('div');
        counter.id = 'submit-counter';
        counter.style.position = 'fixed';
        counter.style.top = '10px';
        counter.style.right = '10px';
        counter.style.background = 'rgba(0,0,0,0.7)';
        counter.style.color = '#fff';
        counter.style.padding = '8px 12px';
        counter.style.fontSize = '16px';
        counter.style.borderRadius = '8px';
        counter.style.zIndex = '9999';
        document.body.appendChild(counter);
    }
    counter.innerText = `âœ… æäº¤æ¬¡æ•°: ${submitCount}`;
}

showCounter();

// âœ… éšæœºè¿è¡Œæ€»æ—¶é•¿ï¼ˆ40~130åˆ†é’Ÿï¼‰
const maxRunTime = (40 + Math.random() * 90) * 60 * 1000; 
const startTime = Date.now();

// âœ… éšæœºä¼‘æ¯é€»è¾‘
async function maybeTakeBreak() {
    if (Math.random() < 0.01) {  // 10% æ¦‚ç‡æ£€æŸ¥
        const breakDuration = (1 + Math.random() * 2) * 60 * 1000; // 1-3åˆ†é’Ÿ
        console.log(`â¸ æ¨¡æ‹Ÿä¼‘æ¯ ${Math.round(breakDuration / 1000)} ç§’`);
        await sleep(breakDuration);
    }
}

while (true) {
    if (Date.now() - startTime > maxRunTime) {
        console.log("âœ… å·²è¿è¡Œåˆ°æœ€å¤§æ—¶é—´ï¼Œè„šæœ¬åœæ­¢");
        break;
    }

    await sleep(1000 + Math.random() * 2500);

    const input = document.querySelector('input[type="text"]');
    if (!input) {
        await sleep(700);
        continue;
    }

    input.focus();
    input.click();

    const submitButton = findButton('Submit to Leaderboard');
    if (submitButton) {
        while (!clickElement(submitButton)) await sleep(1000);
        await sleep(1000 + Math.random() * 2000); // 1~3ç§’éšæœºç­‰å¾…

        submitCount++;
        showCounter();

        const playAgainButton = findButton('Play Again');
        if (playAgainButton) {
            while (!clickElement(playAgainButton)) await sleep(600);
            console.log(`âœ… ç‚¹å‡»å…ƒç´ : ${playAgainButton.textContent.trim()}`);
            await sleep(2000 + Math.random() * 8000);
            await waitForInputFocusAndNewWord();
            triggerSingleTab();
            continue;
        }
    }

    const wordElems = document.querySelectorAll('div[class*="text-"]');
    const activeWord = Array.from(wordElems).find(el =>
        el.innerText.trim().length > 0 &&
        window.getComputedStyle(el).color === 'rgb(255, 255, 255)'
    );

    if (!activeWord) {
        await sleep(500);
        continue;
    }

    await sleep(300 + Math.random() * 300);

    const word = activeWord.innerText.trim();
    console.log(`ğŸ“ æ­£åœ¨è¾“å…¥: ${word}`);

    let current = '';
    let i = 0;

    while (i < word.length) {
        const errorRoll = Math.random();

        if (errorRoll < ERROR_PROB) {
            const fixRoll = Math.random();
            if (fixRoll < FIX_PROB) {
                // è‡ªåŠ¨æ”¹æ­£
                if (Math.random() < 0.5) {
                    i++;
                    await sleep(150 + Math.random() * 150);
                    continue;
                } else {
                    const wrongChar = randomWrongChar();
                    current += wrongChar;
                    triggerInput(input, current);
                    await sleep(150 + Math.random() * 100);
                    current = current.slice(0, -1);
                    triggerBackspace(input, current);
                    await sleep(200 + Math.random() * 200);
                    current += word[i];
                    triggerInput(input, current);
                    await sleep(150 + Math.random() * 80);
                    i++;
                    continue;
                }
            } else {
                // ä¸æ”¹æ­£
                if (Math.random() < 0.5) {
                    i++;
                    await sleep(150 + Math.random() * 100);
                    continue;
                } else {
                    const wrongChar = randomWrongChar();
                    current += wrongChar;
                    triggerInput(input, current);
                    await sleep(150 + Math.random() * 100);
                    i++;
                    continue;
                }
            }
        }

        current += word[i];
        triggerInput(input, current);
        await sleep(140 + Math.random() * 100);
        i++;
    }

    current += ' ';
    triggerInput(input, current);
    await sleep(200 + Math.random() * 150);

    if (wordElems.length === 1) {
        await triggerDoubleTab();
        await sleep(900);

        const playAgainButton = findButton('Play Again');
        if (playAgainButton) {
            while (!clickElement(playAgainButton)) await sleep(600);
            await sleep(2000 + Math.random() * 8000);
            await waitForInputFocusAndNewWord();
            triggerSingleTab();
        }
    }

    await maybeTakeBreak();  // æ£€æŸ¥æ˜¯å¦éœ€è¦ä¼‘æ¯
    await sleep(500 + Math.random() * 300);
}
